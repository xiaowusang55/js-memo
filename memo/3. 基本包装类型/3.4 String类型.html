<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>
        
//String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。
        
        // var stringObject = new String("hello world");

/*
String 对象的方法也可以在 所有基本的字符串值 中访问到。
其中，继承的 valueOf()、toLocale- String()和 toString()方法，都返回对象所表示的基本字 符串值。
*/


//String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。

        // var stringValue = "hello world";
        // console.log(stringValue.length); //11


//两个用于访问字符串中特定字符的方法是:charAt()和 charCodeAt()。这两个方法都接收一个 参数，即基于 0 的字符位置。
//charAt()方法以 单字符字符串 的形式返回 给定位置 的那个 字符 (ECMAScript 中没有字符类型)    

        // var stringValue = "hello world";
        // console.log(stringValue.charAt(1)); // "e"

//charCodeAt() 以 数字 的形式返回 给定位置 的那个 字符的 ascii码。

        // var stringValue = "hello world";
        // console.log(stringValue.charCodeAt(1));// 101

//ECMAScript 5 还定义了另一个访问个别字符的方法。
//在支持此方法的浏览器中，可以使用 方括号 加 数字索引 来 访问字符串中的特定字符。

        // var stringValue = "hello world";
        // console.log(stringValue[1]);

//由于字符串可以通过 方括号 加 数字索引 方式访问。
// 字符串也可以使用 for循环遍历 字符串的每一项。也可以调用 concate(), slice(), indexOf() 进行字符串操作。
        // var str = "hello world";
        // for (var i = 0; i < str.length; i++) {
        //     console.log(i, str[i]);
        // }
        // console.log(str);

// concate() 用于将 一 或 多个 字符串拼接起来，返回拼接得到的新字符串。
// 不会修改字符串本身的值 ——只是 返回一个基本类型的字符串值，对原始字符串没有任何影响。
/* 虽然 concat()是专门用来拼接字符串的方 11 法，但实践中使用更多的还是加号操作符(+)。
而且，使用加号操作符在大多数情况下都比使用 concat() 方法要简便易行(特别是在拼接多个字符串的情况下)。
*/
        // var stringValue = "hello ";
        // var result = stringValue.concat("world");
        // console.log(result);
        // console.log(stringValue);

        // var result = stringValue.concat("world", "!");
        // console.log(result);
        // console.log(stringValue);


/*
ECMAScript 还提供了三个基于子字符串创建新字符串的方法:slice()、substr()和 substring()。
这三个方法都会返回被操作字符串的一个子字符串，第一个参数指定子字 符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。
slice()和 substring()的第二个参数指定的是子字符串最后一个字符后面的位置。
substr()的第二个参数指定的则是返回的字符个数。
如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。
*/
        // var stringValue = "hello world";
        // console.log(stringValue.slice(3));  "lo world"
        // console.log(stringValue.substring(3)); "lo world" 
        // console.log(stringValue.substr(3)); "lo world"
        // console.log(stringValue.slice(3, 7)); "lo w"
        // console.log(stringValue.substring(3, 7)); "lo w"
        // console.log(stringValue.substr(3, 7)); "lo worl"
 
//在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。
//slice()方法会将传 入的负值与字符串的长度相加.
//substring()方法会把所有负值参数都转换为 0。
//substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0
        // var stringValue = "hello world";
        // console.log(stringValue.slice(-3));  "rld"
        // console.log(stringValue.substring(-3)); "hello world" 
        // console.log(stringValue.substr(-3)); "rld"
        // console.log(stringValue.slice(3, -4)); "lo w"
        // console.log(stringValue.substring(3, -4)); "hel" //相当于调用了 substring(0,3)
        // console.log(stringValue.substr(3, -4)); ""


//indexOf()和 lastIndexOf()。
//indexOf()方法从字符串的开头向后搜索子字符串。
//lastIndexOf()方法 是从字符串的末尾向前搜索子字符串。
/*
这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。
换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符;
而 lastIndexOf()则会从 指定的位置向前搜索，忽略该位置之后的所有字符。
*/
        // var stringValue = "hello world";
        // console.log(stringValue.indexOf("o")); //4
        // console.log(stringValue.lastIndexOf("o")); //7

        // console.log(stringValue.indexOf("o", 6)); //7
        // console.log(stringValue.lastIndexOf("o", 6));//4


//demo：在一个字符串中，找出某个字符出现的所有索引位置。
        
        // var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit"
        // var positions = new Array();
        // var pos = stringValue.indexOf("e");

        // while (pos > -1) {
        //     positions.push(pos);
        //     pos = stringValue.indexOf("e", pos + 1);
        // }

        // console.log(positions);



//trim() 方法
//这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果。

        // var stringValue = "        hello world     ";
        // var trimedStringValue = stringValue.trim();
        // console.log(stringValue);
        // console.log(trimedStringValue);

//toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。
/*
toLocaleLowerCase()和 toLocaleUpperCase()方法则是针对特定地区的实现。
对有些地 区来说，针对地区的方法与其通用方法得到的结果相同，
但少数语言(如土耳其语)会为 Unicode 大小 写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。
*/
//一般来说，在不知道自己的 代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。

        // var stringValue = "hello world";
        // console.log(stringValue.toLocaleUpperCase());
        // console.log(stringValue.toUpperCase());
        // console.log(stringValue.toLocaleLowerCase());
        // console.log(stringValue.toLowerCase());



//String 类型定义了几个用于在字符串中匹配模式的方法。match()
//match()，在字符串上调用这个方法，本质上与调用 RegExp 的 exec()方法相同。
// match()方法只接受一个参数，要么是一 个正则表达式，要么是一个 RegExp 对象。

        // var text = "cat, bat, sat, fat";
        // var pattern = /.at/;

        // var matches = text.match(pattern);
        // console.log(matches.index);
        // console.log(matches[0]);
        // console.log(pattern.lastIndex);
        

//search()
//方法的唯一参数与 match()方法的参数相同:由字 符串或 RegExp 对象指定的一个正则表达式。
//search()方法返回字符串中第一个匹配项的索引;如果没 有找到匹配项，则返回-1。
//search()方法始终是从字符串开头向后查找模式

        // var text = "cct, bat, sat, fat";
        // var pos = text.search(/at/);
        // console.log(pos); //6


//replace()
//第一个参数可以是一个 RegExp 对象 或者 一个字符串(这个字符串不会被转换成正则表达式).
//第二个参数可以是一个字符串或者一个函数。
//如果第一个参数是字符串，那么只会替换第一个子字符串。要想替 换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局(g)标志，

        // var text = "cat, bat, sat, fat";
        // var result0 = text.replace("at", "ond")
        // console.log(result0);

        // var result1 = text.replace(/.at/g, "ond");
        // console.log(result1);

        // var result2 = text.replace(/.t/g, () => { return "hahaah"})
        // console.log(result2);


/*
字符序列                           替换文本
$$                                  $
$&                            匹配整个模式的子字符串。与RegExp.lastMatch的值相同。
$'                            匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同。
$`                            匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同。
$n                            匹配第n个捕获组的子字符串，其中n等于0~9。例如，$1是匹配第一个捕获组的子字符串，$2是匹配第
                                    二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串。
$nn                           匹配第nn个捕获组的子字符串，其中nn等于01~99。例如，$01是匹配第一个捕获组的子字符串，$02
                                    是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串。
*/
        // var text = "cat, bat, sat, fat";
        // var result0 = text.replace(/(.at)/g, "word($1)");
        // console.log(result0);


/*
replace()方法的第二个参数也可以是一个函数。
在只有一个匹配项(即与模式匹配的字符串)的 情况下，会向这个函数传递 3 个参数: 模式的匹配项、模式匹配项在字符串中的位置和原始字符串。
在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹 配项、第二个捕获组的匹配项......，
    但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始 字符串。
*/

        // function htmlEscape(text){
        //     return text.replace(/[<>"&]/g, function(match, pos, originalText){
        //             switch(match){
        //                 case "<":
        //                     return "&lt;";
        //                 case ">":
        //                     return "&gt;";
        //                 case "&":
        //                     return "&amp;";
        //                 case "\"":
        //                     return "&quot;";
        // } });
        // }
        // console.log(htmlEscape("<p class=\"greeting\">Hello world!</p>")); //&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;



//split() 基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中
/*
分隔符可以是字符串，也可以是一个 RegExp 对象(这个方 法不会将字符串看成正则表达式),
split()方法可以接受可选的第二个参数，用于指定数组的大小， 以便确保返回的数组不会超过既定大小。
*/
        // var colorText = "red, blue, green, yellow";
        // var colors1 = colorText.split(",");
        // console.log(colors1);
        // var colors2 = colorText.split(",", 2);
        // console.log(colors2);
        // var colors3 = colorText.split(/[^\,]+/);
        // console.log(colors3);



/*
//RegExp Brackets
Expression                      Description
[abc]                       Find any character between the brackets
[^abc]                      Find any character NOT between the brackets
[0-9]                       Find any character between the brackets (any digit)
[^0-9]                      Find any character NOT between the brackets (any non-digit)
(x|y)                       Find any of the alternatives specified

//Metacharacters
Metacharacter                   Description
.                           Find a single character, except newline or line terminator
\w                          Find a word character
\W                          Find a non-word character
\d                          Find a digit
\D                          Find a non-digit character
\s                          Find a whitespace character
\S                          Find a non-whitespace character
\b                          Find a match at the beginning/end of a word, beginning like this: \bHI, end like this: HI\b
\B                          Find a match, but not at the beginning/end of a word
\0                          Find a NUL character
\n                          Find a new line character
\f                          Find a form feed character
\r                          Find a carriage return character
\t                          Find a tab character
\v                          Find a vertical tab character
\xxx                        Find the character specified by an octal number xxx
\xdd                        Find the character specified by a hexadecimal number dd
\udddd                      Find the Unicode character specified by a hexadecimal number dddd

//Quantifiers
Quantifier                      Description
n+                          Matches any string that contains at least one n
n*                          Matches any string that contains zero or more occurrences of n
n?                          Matches any string that contains zero or one occurrences of n
n{X}                        Matches any string that contains a sequence of X n's
n{X,Y}                      Matches any string that contains a sequence of X to Y n's
n{X,}                       Matches any string that contains a sequence of at least X n's
n$                          Matches any string with n at the end of it
^n                          Matches any string with n at the beginning of it
?=n                         Matches any string that is followed by a specific string n
?!n                         Matches any string that is not followed by a specific string n

*/


//localeCompare()  
/*
这个方法比较两个字符串，并返回下列 值中的一个:
-如果 字符串 在 字母表中 应该排在 字符串参数 之前，则返回一个负数(大多数情况下是-1，具体 的值要视实现而定);
-如果字符串等于字符串参数，则返回 0;
-如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是 1，具体的值同样要视实现而定)。
*/

        // var stringValue = "yellow";
        // console.log(stringValue.localeCompare("brick")); //1
        // console.log(stringValue.localeCompare("yellow")); //0
        // console.log(stringValue.localeCompare("zoo")); //-1

//localeCompare()返回的数值取决于实现，所以最好是像下面例子所示 的这样使用这个方法。

        // function determineOrder(value) {
        //     var result = stringValue.localeCompare(value);
        //     if (result < 0) {
        //         console.log("The string 'yellow' comes before the string '" + value + "'.");
        //     } else if (result > 0) {
        //         console.log("The string 'yellow' comes after the string '" + value + "'.");
        //     } else {
        //         console.log("The string 'yellow' is equal to the string '" + value + "'.");
        //     }
        // }
        // determineOrder("brick");
        // determineOrder("yellow");
        // determineOrder("zoo");


//fromCharCode() 
//String 构造函数本身还有一个静态方法:fromCharCode()。
//这个方法的任务是接收一或 多个字符编码，然后将它们转换成一个字符串。

        // console.log(String.fromCharCode(104, 101, 108, 108, 111)); //hello


/*
早期的 Web 浏览器提供商觉察到了使用 JavaScript 动态格式化 HTML 的需求。于是，这些提供商就
扩展了标准，实现了一些专门用于简化常见 HTML 格式化任务的方法。下表列出了这些 HTML 方法。 
不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。

方法                                             输出结果
anchor(name)                           <a name= "name">string</a>
big()                                  <big>string</big>
bold()                                 <b>string</b>
fixed()                                <tt>string</tt>
fontcolor(color)                       <font color="color">string</font> 
fontsize(size)                          <font size="size">string</font> 
italics()                               <i>string</i>
link(url)                              <a href="url">string</a> 
small()                                 <small>string</small> 
strike()                               <strike>string</strike> 
sub()                                  <sub>string</sub>
sup()                                  <sup>string</sup>

            // var test = "for test";
            // console.log(test.anchor("hahaha")); //<a name="hahaha">for test</a>
            // console.log(test.big());            //<big>for test</big>
            // console.log(test.bold());           //<b>for test</b>
            // ...
*/


























    </script>




</body>
</html>