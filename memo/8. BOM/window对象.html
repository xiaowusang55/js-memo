<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>
        
/*
ECMAScript 是JavaScript 的核心，但如果要在Web 中使用JavaScript，那么BOM（浏览器对象模
型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任
何网页内容无关。多年来，缺少事实上的规范导致BOM既有意思又有问题，因为浏览器提供商会按照各
自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以
存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C 为了把浏览器中JavaScript 最基本的部分
标准化，已经将BOM的主要方面纳入了HTML5 的规范中。

*/

// window 对象
/* 
BOM 的核心对象是window，它表示浏览器的一个实例。
在浏览器中，window 对象有双重角色，
它既是通过JavaScript 访问浏览器窗口的一个接口，又是ECMAScript 规定的Global 对象。
这意味着在网页中定义的任何一个对象、变量和函数，都以window 作为其Global 对象，因此有权访问
parseInt()等方法。

//全局作用域
由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此所有在全局作用域中声明
的变量、函数都会变成window 对象的属性和方法。

    var age = 29;
    function sayAge(){
    alert(this.age);
    }
    alert(window.age); //29
    sayAge(); //29
    window.sayAge();

    我们在全局作用域中定义了一个变量age 和一个函数sayAge()，它们被自动归在了window 对象
    名下。于是，可以通过window.age 访问变量age，可以通过window.sayAge()访问函数sayAge()。
    由于sayAge()存在于全局作用域中，因此this.age 被映射到window.age，最终显示的仍然是正确
    的结果。

抛开全局变量会成为window 对象的属性不谈，定义全局变量与在window 对象上直接定义属性还
是有一点差别：全局变量不能通过delete 操作符删除，而直接在window 对象上的定义的属性可以。
例如：

    var age = 29;
    window.color = "red";
    //在IE < 9 时抛出错误，在其他所有浏览器中都返回false
    delete window.age;
    //在IE < 9 时抛出错误，在其他所有浏览器中都返回true
    delete window.color; //returns true
    alert(window.age); //29
    alert(window.color); //undefined

    刚才使用var 语句添加的window 属性有一个名为[[Configurable]]的特性，这个特性的值被
    设置为false，因此这样定义的属性不可以通过delete 操作符删除。IE8及更早版本在遇到使用delete
    删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版
    本不会抛出错误。

    另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询window 对象，可以知
    道某个可能未声明的变量是否存在。例如：

    //这里会抛出错误，因为oldValue 未定义
    var newValue = oldValue;
    //这里不会抛出错误，因为这是一次属性查询
    //newValue 的值是undefined
    var newValue = window.oldValue;

本章后面将要讨论的很多全局JavaScript 对象（如location 和navigator）实际上都是window
对象的属性。



//窗口关系及框架 

如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在frames 集合中。在frames
集合中，可以通过数值索引（从0 开始，从左至右，从上到下）或者框架名称来访问相应的window 对
象。每个window 对象都有一个name 属性，其中包含框架的名称。下面是一个包含框架的页面：

    <html>
    <head>
    <title>Frameset Example</title>
    </head>
    <frameset rows="160,*">
    <frame src="frame.htm" name="topFrame">
    <frameset cols="50%,50%">
    <frame src="anotherframe.htm" name="leftFrame">
    <frame src="yetanotherframe.htm" name="rightFrame">
    </frameset>
    </frameset>
    </html>

    以上代码创建了一个框架集，其中一个框架居上，两个框架居下。对这个例子而言，可以通过
    window.frames[0]或者window.frames["topFrame"]来引用上方的框架。不过，恐怕你最好使用
    top 而非window 来引用这些框架（例如，通过top.frames[0]）。

我们知道，top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个
框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window 对象指向
的都是那个框架的特定实例，而非最高层的框架。图8-1 展示了在最高层窗口中，通过代码来访问前面
例子中每个框架的不同方式。

与top 相对的另一个window 对象是parent。顾名思义，parent（父）对象始终指向当前框架的
直接上层框架。在某些情况下，parent 有可能等于top；但在没有框架的情况下，parent 一定等于
top（此时它们都等于window）。

    <html>
    <head>
    <title>Frameset Example</title>
    </head>
    <frameset rows="100,*">
    <frame src="frame.htm" name="topFrame">
    <frameset cols="50%,50%">
    <frame src="anotherframe.htm" name="leftFrame">
    <frame src="anotherframeset.htm" name="rightFrame">
    </frameset>
    </frameset>
    </html>

这个框架集中的一个框架包含了另一个框架集，该框架集的代码如下所示。

    <html>
    <head>
    <title>Frameset Example</title>
    </head>
    <frameset cols="50%,50%">
    <frame src="red.htm" name="redFrame">
    <frame src="blue.htm" name="blueFrame">
    </frameset>
    </html>

    浏览器在加载完第一个框架集以后，会继续将第二个框架集加载到rightFrame 中。如果代码位于
    redFrame（或blueFrame）中，那么parent 对象指向的就是rightFrame。可是，如果代码位于
    topFrame 中，则parent 指向的是top，因为topFrame 的直接上层框架就是最外层框架。图8-2 展
    示了在将前面例子加载到浏览器之后，不同window 对象的值。

注意，除非最高层窗口是通过window.open()打开的（本章后面将会讨论），否则其window 对象
的name 属性不会包含任何值。

与框架有关的最后一个对象是self，它始终指向window；实际上，self 和window 对象可以互
换使用。引入self 对象的目的只是为了与top 和parent 对象对应起来，因此它不格外包含其他值。

所有这些对象都是window 对象的属性，可以通过window.parent、window.top 等形式来访问。
同时，这也意味着可以将不同层次的window 对象连缀起来，例如window.parent.parent.frames[0]。

在使用框架的情况下，浏览器中会存在多个Global 对象。在每个框架中定义的
全局变量会自动成为框架中window 对象的属性。由于每个window 对象都包含原生
类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，
但并不相等。例如，top.Object 并不等于top.frames[0].Object。这个问题会
影响到对跨框架传递的对象使用instanceof 操作符。


//窗口位置

用来确定和修改window 对象位置的属性和方法有很多。IE、Safari、Opera 和Chrome 都提供了
screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox 则在
screenX 和screenY 属性中提供相同的窗口位置信息，Safari 和Chrome 也同时支持这两个属性。Opera
虽然也支持screenX 和screenY 属性，但与screenLeft 和screenTop 属性并不对应，因此建议大
家不要在Opera 中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。

    var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
    var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;


    这个例子运用二元操作符首先确定screenLeft 和screenTop 属性是否存在，如果是（在IE、
    Safari、Opera 和Chrome 中），则取得这两个属性的值。如果不存在（在Firefox 中），则取得screenX
    和screenY 的值。

在使用这些值的过程中，还必须注意一些小问题。在 IE、Opera 中，screenLeft 和 screenTop 中保存 
的是从屏幕左边和上边到由 window 对象表示的页面可见区域的距离。换句话说，如果 window 对象是 
最外层对象，而且浏览器窗口紧贴屏幕最上端——即 y轴坐标为 0，那么 screenTop 的值就是位于页面 
可见区域上方的浏览器工具栏的像素高度。但是，在 Chrome、Firefox 和 Safari 中，screenY 或 screenTop 中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的 y 轴坐标为 0 时返回 0。

Firefox、Safari 和 Chrome 始终返回页面中每个框架的 top.screenX 和 top.screenY 值。即使在页面由于被设置了外边􏲜而发生偏移的情况下，相对于 window 对象使用 screenX 
和 screenY 每次也都会返回相同的值。而 IE 和 Opera 则会给出框架相对于屏幕边界的精确坐标值。

最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。
然而，使用 moveTo() 和 moveBy()方法倒是有可能将窗口精确地移动到一个新位置。
这两个方法都接收两个参数，其中moveTo()接收的是新位置的 x 和 y 坐标值，
而 moveBy()接收的是在水平和垂直方向上移动的像素数。

    //将窗口移动到屏幕左上角
    window.moveTo(0, 0);

    //将窗口向下移动 100像素
    window.moveBy(0, 100)

    //将窗口移动到(200,300) 
    window.moveTo(200,300);

    //将窗口向左移动 50像素 
    window.moveBy(-50,0);

    需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就
    是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。


//窗口大小

跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和Chrome 均为此提
供了4 个属性：innerWidth、innerHeight、outerWidth 和outerHeight。

在IE9+、Safari 和Firefox
中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从
某个框架访问）
在Opera 中，这两个属性的值表示页面视图容器①的大小。。而innerWidth 和innerHeight
则表示该容器中页面视图区的大小（减去边框宽度）
在Chrome 中，outerWidth、outerHeight 与
innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。

在IE、Firefox、Safari、Opera 和Chrome 中，document.documentElement.clientWidth 和
document.documentElement.clientHeight 中保存了页面视口的信息。在IE6 中，这些属性必须在
标准模式下才有效；
如果是混杂模式，就必须通过document.body.clientWidth 和document.body.
clientHeight 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement
还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。

    虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。

    var pageWidth = window.innerWidth,
    pageHeight = window.innerHeight;
    if (typeof pageWidth != "number"){
    if (document.compatMode == "CSS1Compat"){
    pageWidth = document.documentElement.clientWidth;
    pageHeight = document.documentElement.clientHeight;
    } else {
    pageWidth = document.body.clientWidth;
    pageHeight = document.body.clientHeight;
    }
    }

    在以上代码中，我们首先将window.innerWidth 和window.innerHeight 的值分别赋给了
    pageWidth 和pageHeight。然后检查pageWidth 中保存的是不是一个数值；如果不是，则通过检查
    document.compatMode（这个属性将在第10 章全面讨论）来确定页面是否处于标准模式。如果是，则
    分别使用document.documentElement.clientWidth 和document.documentElement.client-
    Height 的值。否则，就使用document.body.clientWidth 和document.body.clientHeight 的值。


对于移动设备，window.innerWidth 和window.innerHeight 保存着可见视口，也就是屏幕上可
见页面区域的大小。移动IE 浏览器不支持这些属性，但通过document.documentElement.client-
Width 和document.documentElement.clientHeihgt 提供了相同的信息。随着页面的缩放，这些值
也会相应变化。

在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大
小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE 浏览器把布局视口的信息保存在
document.body.clientWidth 和document.body.clientHeight 中。这些值不会随着页面缩放变化。
由于与桌面浏览器间存在这些差异，最好是先检测一下用户是否在使用移动设备，然后再决定使用
哪个属性。

另外，使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个
参数，其中resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽
度和高度之差。来看下面的例子。

    //调整到100×100
    window.resizeTo(100, 100);
    //调整到200×150
    window.resizeBy(100, 50);
    //调整到 300×300
    window.resizeTo(300, 300);

    需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera
    和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的
    window 对象使用。


//导航和打开窗口

使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。
这个方法可以接收4 个参数：
要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。
通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。

如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具
有该名称的窗口或框架中加载第一个参数指定的URL。看下面的例子。

    //等同于< a href="http://www.wrox.com" target="topFrame"></a>
    window.open("http://www.wrox.com/", "topFrame");

    调用这行代码，就如同用户单击了href 属性为http://www.wrox.com/，target 属性为"topFrame"
    的链接。如果有一个名叫"topFrame"的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就
    会创建一个新窗口并将其命名为"topFrame"。此外，第二个参数也可以是下列任何一个特殊的窗口名
    称：_self、_parent、_top 或_blank

//弹出窗口
如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根
据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会
打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页—
—根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。

第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现
在这个字符串中的设置选项。

设 置               值                      说 明
fullscreen         yes或no          表示浏览器窗口是否最大化。仅限IE
height             数值             表示新窗口的高度。不能小于100
left                数值          表示新窗口的左坐标。不能是负值
location            yes或no          表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果
                                    设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）
menubar             yes或no         表示是否在浏览器窗口中显示菜单栏。默认值为no
resizable           yes或no         表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no
scrollbars          yes或no         表示如果内容在视口中显示不下，是否允许滚动。默认值为no
status              yes或no         表示是否在浏览器窗口中显示状态栏。默认值为no
toolbar             yes或no         表示是否在浏览器窗口中显示工具栏。默认值为no
top                 数值            表示新窗口的上坐标。不能是负值
width               数值            表示新窗口的宽度。不能小于100

表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号
表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。

    window.open("http://www.wrox.com/","wroxWindow",
    "height=400,width=400,top=10,left=10,resizable=yes");

    这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400×400 像素，并且距屏幕上沿
    和左边各10 像素。


window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window 对象大致相似，但
我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大
小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返
回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。

    var wroxWin = window.open("http://www.wrox.com/","wroxWindow",
    "height=400,width=400,top=10,left=10,resizable=yes");
    //调整大小
    wroxWin.resizeTo(500,500);
    //移动位置
    wroxWin.moveTo(100,100);
    调用close()方法还可以关闭新打开的窗口。
    wroxWin.close();

新创建的window 对象有一个opener 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出
窗口中的最外层window 对象（top）中有定义，而且指向调用window.open()的窗口或框架。例如：

    var wroxWin = window.open("http://www.wrox.com/","wroxWindow",
    "height=400,width=400,top=10,left=10,resizable=yes");
    alert(wroxWin.opener == window); //true

虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗
口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。

有些浏览器（如IE8 和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标
签页时，如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome
中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页，如下所示。

    var wroxWin = window.open("http://www.wrox.com/","wroxWindow",
    "height=400,width=400,top=10,left=10,resizable=yes");
    wroxWin.opener = null;

将opener 属性设置为null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此
可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。

//安全限制

曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成
系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真
是假。为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。

Windows XP SP2 中的IE6 对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗
口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。IE7 则增加了更多的安全限制，如不允
许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1 从一开始就不支持修改状态栏，
因此无论给window.open()传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来
的Firefox 3 又强制始终在弹出窗口中显示地址栏。Opera 只会在主浏览器窗口中打开弹出窗口，但不允
许它们出现在可能与系统对话框混淆的地方。

此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用
window.open()的语句根本不会执行，而且还可能会将错误消息显示给用户。换句话说，只能通过单
击或者击键来打开弹出窗口。
对于那些不是用户有意打开的弹出窗口，Chrome 采取了不同的处理方式。它不会像其他浏览器那
样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。

//弹出窗口屏蔽程序

大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装Yahoo!
Toolbar 等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。于
是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那
么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽
了，如下面的例子所示。

    var wroxWin = window.open("http://www.wrox.com", "_blank");
    if (wroxWin == null){
    alert("The popup was blocked!");
    }

如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，
要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装
在一个try-catch 块中，如下所示。

    var blocked = false;
    try {
    var wroxWin = window.open("http://www.wrox.com", "_blank");
    if (wroxWin == null){
    blocked = true;
    }
    } catch (ex){
    blocked = true;
    }
    if (blocked){
    alert("The popup was blocked!");
    }  

在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽了。但
要注意的是，检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关
的消息。

//间歇调用和超时调用

*/















    
    
    </script>



</body>
</html>