<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>
    
//实例化一个名为 sum 的函数
        // function sum (num1, num2) {
        //     return num1 + num2;
        // }    

// 定义一个匿名函数，并赋值给变量 sum
        // var sum = function (num1, num2) {
        //     return num1 + num2;
        // };

// 使用 new 关键字， 加上 构造函数 实例化函数。但不推荐。
        // var sum = new Function("num1", "num2", "return num1 + num2");


// 函数的分为普通函数，匿名函数。说明函数名不是必须使用的，如匿名函数可以通过变量名 sum 引用函数。
// 由于函数名仅仅是指向函数的指针，因此函数名 与 包含对象指针 的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。如下。
// 即使将 sum 设置为 null， 让它与函数 “断绝关系”，但任然可以正常调用 anotherSum()。
        // function sum (num1, num2) {
        //     return num1 + num2;
        // }
        // console.log(sum(5, 5));

        // var anotherSum = sum;
        // console.log(anotherSum(5, 5));

        // sum = null;
        // console.log(null);
        // console.log(anotherSum(9, 8));
            
//Function, Array, Date, RegExp 均为引用数据类型。它们的变量名都不是必须的，仅仅是指针，所以变量名有多个。   
        // var arr = [2, 3, 5];
        // newArr = arr;
        // console.log(newArr);
        
        // newArr[0] = 666;
        // console.log(arr);

        // arr = null;
        // console.log(arr);
        
        // newArr[2] = 99999;
        // console.log(newArr);

//一个函数可以赋值给多个变量名，但一个变量名只能指向一个函数。当一个变量名指向两个函数时，后面的函数会将 前面的 函数覆盖掉。其他引用类型同理。
//普通函数
        // function addSomeNumber(num) {
        //     return num + 100;
        // }

        // function addSomeNumber(num) {
        //     return num + 200;
        // }
        // var result = addSomeNumber(100)  //300

// 匿名函数
        // var addSomeNumber = function (num) {
        //     return num + 100;
        // };

        // addSomeNumber = function (num) {
        //     return num + 200;
        // };
        // var result = addSomeNumber(100)  //300
                    

// 函数声明提升（function declaration hoisting） 只存在于函数中，因为函数除了 new + 构造函数定义方式除外，还可以通过
// 关键字进行定义。     
// 基本数据类型 string， number，boolean， 和引用数据类型 array, date, regexp 都是通过 new + 构造函数定义方式，
// 或者直接字面量定义，没有通过 关键字 进行定义，故没有声明提升的概念。

        // console.log(sum(10, 10)); // 可以正常输出
        // function sum (num1, num2) {
        //         return num1 + num2;
        // }


        // console.log(sum(10, 10));
        // var sum = function (num1, num2) {
        //         return num1 + num2;
        // }

// 同时使用 函数声明 和 函数表达式， 但 safari 会报错。
        // var sum = function sum (num1, num2) {
        //         return num1 + num2;
        // }
        // console.log(sum(10, 10));


// 将函数的变量名（函数的指针），作为另一个函数的参数。
        
        // function callSomeFunction(someFunction, someArgument) {
        //         return someFunction(someArgument);
        // }
        
        // function add10 (num) {
        //         return num + 10;
        // }

        // var result = callSomeFunction(add10, 10)
        // console.log(result);

// 从一个函数中返回另一个函数。
        // function creatComparisonFunction (propertyName) {
        //         return function(object1, object2) {
        //                 var value1 = object1[propertyName];
        //                 var value2 = object2[propertyName];

        //                 if (value1 < value2) {
        //                         return -1;
        //                 } else if (value1 > value2) {
        //                         return 1;
        //                 } else {
        //                         return 0;
        //                 }
        //         };
        // }

        // var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
        // data.sort(creatComparisonFunction("name"));
        // console.log(data[0].name);
        // console.log(data);

        // data.sort(creatComparisonFunction("age"));
        // console.log(data[0].name);
        
//递归方法 定义阶乘函数
// 但问题是这个函数的执行与函数名factorial 紧紧耦合在了一起。为
// 了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。
//callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。
        // function factorial(num) {
        //         if (num <= 1) {
        //                 return 1;
        //         } else {
        //                 return num * factorial(num - 1)
        //         }
        // }

        // console.log(factorial(5));


        // function factorial(num) {
        //         if (num <= 1) {
        //                 return 1;
        //         } else {
        //                 return num * arguments.callee(num - 1)
        //         }
        // }

        // console.log(factorial(5));
        

// this 是函数内部的另一个特殊对象。 this 引用的是函数数 据以执行的 环境对象。
// （当在网页的全局作用域中调用函数时，this 对象引用的就是 window ）。
//函数的名字仅仅是一个包含指针的变量而已。因此，即使是
// 在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一
// 个函数。
        
        // window.color = "red";
        // var o = {color: "blue"};

        // function sayColor () {
        //         console.log(this.color);
        // }
        // sayColor(this.color);

        // o.sayColor = sayColor; //"red"
        // o.sayColor(); //"blue"



// ECMAScript 5 也规范化了另一个函数对象的属性：caller.
// 这个属性中保存着调用当前函数的函数的引用，
// 如果是在全局作用域中调用当前函数，它的值为null
        
        // function outer () {
        //         inner();
        // }

        // function inner () {
        //         console.log(inner.caller);
        // }
        // outer();


        // function outer() {
        //         inner();
        // }

        // function inner () {
        //         console.log(arguments.callee.caller);
        // }


//函数属性 length。表示函数希望接收的 命名参数 的个数。
        
        // function sayName(name) {
        //     console.log(name);
        // }
        // function sum(num1, num2) {
        //     return num1 + num2;
        // }
        // function sayHi () {
        //     console.log("hi");
        // }
        
        // console.log(sayName.length);//1
        // console.log(sum.length);    //2
        // console.log(sayHi.length);  //0


//任何函数都包含两个非继承而来的方法： apply()  call()。
//这两个方法的用途都是 在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。
//apply() 方法接收两个参数值：一个是在其中运行函数的作用域，另一个是参数数组。 其中第二个参数可以是 Array 的实例，也可以是 arguments对象。

        // function sum(num1, num2) {
        //     return num1 + num2;
        // }

        // function callSum1(num1, num2) {
        //     return sum.apply(this, arguments)
        // }
        
        // function callSum2(num1, num2) {
        //     return sum.apply(this, [num1, num2]);
        // }
        // console.log(callSum1(10, 10)); //20
        // console.log(callSum2(10, 10)); //20

// call() 方法与 apply() 方法的作用相同。
//对于 call() 方法而言，第一个参数是 this 值没有变化，但是传递给函数的参数必须逐个列举出来。
        
        // function sum(num1, num2) {
        //     return num1 + num2;
        // }

        // function callSum(num1, num2) {
        //     return sum.call(this, num1, num2);
        // }

        // console.log(callSum(10, 10)); //20
    
//apply() call() 的真正强大之处，扩充函数赖以运行的作用域。
//使用 apply() call() 来扩充作用域的最大好处， 就是不需要与方法有任何耦合关系。在前面例子的第一个版本中，
//我们是先将 sayColor() 函数放到了对象 o 中，然后再通过 o 来调用 sayColor。在这里重写的例子中，就不需要用这一多余的步骤了。

        // window.color = "red";
        // var o = { color: "blue" };

        // function sayColor() {
        //     console.log(this.color);
        // }
        // sayColor(); // red

        // sayColor.call(this); //red
        // sayColor.call(window); //red
        // sayColor.call(o); //blue

//ECMAScript 5 还定义一个函数方法： bind()。
//这个方法会创建一个实例， 其 this 值会被绑定到 传给 bind() 函数的值。

        // window.color = "red";
        // var o = { color: "blue" };

        // function sayColor() {
        //     console.log(this.color);
        // }
        // var objectSayColor = sayColor.bind(o);
        // objectSayColor();  //blue



        








    </script>





</body>
</html>